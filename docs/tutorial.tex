\documentclass{cs195u}

\usepackage{hyperref}

\usepackage{listings}
\usepackage[T1]{fontenc}
\lstset{
  basicstyle=\small\ttfamily,
  columns=flexible,
  breaklines=true
}

\misc{Warmup Guide}
\docdate{Spring 2021}

\begin{document}

\section*{Introduction}
Hi there! This guide is designed to help you get setup for taking CS1950U. It will go through the basics of using the support code. However, this guide is in no way comprehensive. After completing the work here, please keep the following things in mind:

\begin{itemize}
\item The TA staff encourages you to look at and play around with the support code. This tutorial will only prepare you for the first week’s assignment!
\item You will be writing C++ code for the entire semester, exercising concepts that are not covered here. If you have not written much C++ code before taking this class we recommend that you read over the CS123 help sessions for C++, found here: \url{https://cs.brown.edu/courses/cs123/docs.shtml}.
\item In addition, although the TA staff has attempted to write comprehensive graphics support code, it will still be helpful (though not necessary) to understand the graphics pipeline and some basic OpenGL concepts such as Vertex Buffer / Array objects, Shaders, Textures, and FBOs. A good introduction to OpenGL can be found here: \url{https://open.gl/drawing}.
\end{itemize}

\section*{Developing Locally}

Visit \url{https://www.qt.io/download-open-source} and download the Qt Installer. Use the installer to install Qt 5.15.2 with Qt Creator. 

\section*{Step 1: Creating a New Project}

\begin{enumerate}
\item You will find the engine code stencil in \path{/course/cs195u/asgn/engine} on the department filesystem. Copy this folder into your home directory (probably something like \path{/course/cs195u/engine})

\item Open Qt Creator (you can use the command \path{/course/cs195u/bin/cs195u_qtcreator} if you are on a department machine) and then open the \path{engine/cs195u_engine.pro} file within Qt Creator. You will be prompted to select your compiler and version of Qt. Build and run the project by clicking the green button in the lower left corner. You should see a black screen. Press Escape to close the program window. Your mouse should be in the center of the screen at each tick. If this is not working, then something might be wrong with your security preferences. Make sure to give Qt Creator and your game engine permission to control your computer.

Once the program is manipulating the mouse properly, open up \texttt{view.cpp}. The \texttt{View} class represents a Qt object which will display your game. On line 31 of \texttt{view.cpp} change \path{Qt::ArrowCursor} to \texttt{Qt::BlankCursor}. Now the cursor will be hidden when inside the window.

\item In C++, every method that you write will be declared in a header file. You will put the implementation of each method in the corresponding source (.cpp) file. You will also declare your instance variables in the header file. Public and private keywords are used in blocks rather than for each method or variable, so all your public methods and variables go in one place, and all your private ones go in one place. Protected methods and variables also exist.

\item Use the \textbf{F4} key to switch between the .cpp and the header file quickly.

\item Take a look at the \texttt{View::View()} method. This is the definition of the constructor of the \texttt{View} class. The constructor sets up your window, hides your cursor (now that you've modified it), and sets up a timer.

\item Take a look at the \texttt{View::View()} method. This is the definition of a destructor of the View class. The destructor of a class is what is called when an object goes out of scope. In this class, the destructor of \texttt{View} will be called at the end of the program.

\item Navigate to \texttt{View::initializeGL()}: this method starts the timer (which triggers tick events) and is where the \texttt{Graphics} object is set up.

\item  Navigate to \texttt{View::paintGL()}: this will be called 60 times per second, and is where you will draw the current state of your game.

The line

         \texttt{m\_graphics->setClearColor(glm::vec3(0, 0, 0));}
         
makes it so that when the screen is cleared, it is painted black, since \texttt{glm::vec3(...)} represents a color specified as amounts of red, green, and blue. In general, we will use \texttt{glm::vec}’s to represent colors, positions, and more.

Change the above line to

         \texttt{m\_graphics->setClearColor(glm::vec3(1, 0, 0));}
         
When you build and run the project, the screen should now be red.

\item Navigate to \texttt{View::mouseMoveEvent(QMouseEvent *event)}: this will be called every time the user moves the mouse.

\item Navigate to \texttt{View::keyPress/ReleaseEvent(QKeyEvent *event)}: this will be called whenever the user presses or releases a key on the keyboard.

\item Navigate to \texttt{View::tick()}: this gets called 60 times a second and is where you will update your game! This is where most of your game happens.
\end{enumerate}

\section*{Setting Up a Camera}

As we discussed in lecture, when working in 3D space, we will will need a virtual “camera” that determines where in our 3D world we are looking. You can think of this as literally placing a video camera in the middle of a room and putting the video from that camera onto the screen.


The support code provides a default camera class in \path{src/graphics/Camera.h} and \path{src/graphics/Camera.cpp} which has the following instance variables:

\begin{itemize}
\item \texttt{glm::vec3 m\_eye;} // Keeps track of the position of the camera
\item  \texttt{float m\_yaw;} // rotation around the y axis (the vertical axis) – the horizontal direction you are looking in

\item  \texttt{float m\_pitch;} // angle with the xz plane (horizontal plane) – how much up or down you are looking
\item  \texttt{float m\_fov;} // field of view – how wide is the camera’s lens
\item  \texttt{glm::vec2 m\_screenSize;} // size of the screen
\end{itemize}

Some of its public methods (declared in the header file, and fleshed out in the .cpp file) are:

\begin{itemize}
\item  \texttt{void setEye(glm::vec3 eye);} // Set the position of the camera
\item  \texttt{void translate(glm::vec3 amount);} // Move the position of the camera by the specified amount
\item  \texttt{void setScreenSize(glm::vec2 screenSize);} // Set the screen size / aspect ratio of the camera
\item  \texttt{void setPitch/Yaw(float pitch/yaw);} // Set pitch / yaw of the camera
\item  \texttt{void setLook(glm::vec3 look);} // Instead of setting the pitch and yaw, you can directly specify the direction you want the camera to face
\end{itemize}

By default, the camera position is the origin, i.e. \texttt{glm::vec3(0, 0, 0)}, the fov is pi / 3 radians (60 degrees), and the pitch and yaw are both 0 radians (0 degrees). This means that it will be looking down the positive z-axis.

\begin{enumerate}
\item  Navigate to the end of the method \texttt{View::initializeGL()} in \path{view.cpp}, and set the \texttt{m\_camera} member variable to a new camera:

\texttt{m\_camera = std::make\_shared<Camera>();}
         
\item  In the same function, set the position of the camera to (0, 1, 0) using 

\texttt{m\_camera->setEye(glm::vec3(0, 1, 0));}

\item  Call \texttt{m\_graphics->setCamera(m\_camera)} so that the graphics object will use \texttt{m\_camera} for rendering.

\item  We need the camera to have an accurate value for the screen size, so navigate to the end of \texttt{View::resizeGL()} and add the line:

        \texttt{m\_camera->setScreenSize(glm::vec2(w, h));} 
\end{enumerate}


\section*{Drawing a Quad}

If you run the project, you should still see a blank screen. Let’s change that. 

In the function \texttt{View::paintGL()}, add the following code:

\texttt{m\_graphics->clearTransform();}\\
\texttt{m\_graphics->scale(20);}\\
\texttt{m\_graphics->drawShape("quad");}

The call \texttt{m\_graphics->clearTransform()} sets the matrix applied to all subsequent shapes equal to the identity matrix. This just means that all shapes drawn after this will be drawn at their “default” size and position. In this example, the quad has width 1 and height 1, and is oriented along the xz plane, with its center at (0, 0, 0).

The subsequent call to \texttt{m\_graphics->scale(20)} adds a scale matrix to the current transform. This means that all shapes drawn after this will be scaled by a factor of 20. Finally, the call to \texttt{m\_graphics->drawShape("quad")} draws a quad aligned with the xz plane. Running the project, part of your screen should now be white. This is your camera looking at a quad.

\section*{Setting the Material}

This quad is great, but it’d be nice to have pretty-looking quads with different colors or even images on them, so let’s see how to do that using \texttt{Material}s.

\begin{enumerate}
\item Open the file \path{src/engine/graphics/Material.h}. There are a ton of member variables here that relate to different material properties; for example, the \texttt{color} variable specifies the color you want your shape to be. The \texttt{useLighting} variable specifies if you want your shape to take lights into account when being drawn. The \texttt{textureName} variable refers to the name of an image stored in the \texttt{Graphics} object, which will be drawn onto your shape.

\item Let’s create a material! Go back to the \texttt{View::initializeGL()} function and add the following code:

         \texttt{Material myFirstMaterial;}\\
         \texttt{myFirstMaterial.color = glm::vec3(0, 1, 0);}\\
         \texttt{m\_graphics->addMaterial("boringGreen", myFirstMaterial);}

The first line \texttt{Material myFirstMaterial;} creates a new default \texttt{Material} object (you can check the \texttt{Material} constructors in \texttt{Material.h} to see what all of the variables will be initialized to by default).

The second line \texttt{myFirstMaterial.color = glm::vec3(0, 1, 0);} is just setting the color of your material to a bright green (the color variable is interpreted as an RGB triplet).

The third line \texttt{m\_graphics->addMaterial("boringGreen", myFirstMaterial);} stores your material in the graphics object under the name “boringGreen”, so that we can recall it later.

\item So let’s use our material! Go back to the \texttt{View::paintGL()} function and add the following line before you draw your quad:

         \texttt{m\_graphics->setMaterial("boringGreen");}.
         
This line sets the current material to “boringGreen”, so that shapes will be drawn using this material.

\item Now let’s create a \texttt{Material} that has a texture associated with it. Create a new material \texttt{mySecondMaterial} and add the line

\texttt{mySecondMaterial.textureName = "grass"}

Using the previous steps to guide you, store this material in the graphics object and use it to render the quad.
\end{enumerate}

\section*{Camera Movement}

In most games, we want the camera to be affected by player key inputs. In this guide, we’ll use the W, A, S, D keys for moving.

\begin{enumerate}
\item In \texttt{View::keyPressEvent()}, add:

     \texttt{glm::vec3 look = m\_camera->getLook();}\\
     \texttt{glm::vec3 dir = glm::normalize(glm::vec3(look.x, 0, look.z));}\\
     \texttt{glm::vec3 perp = glm::vec3(dir.z, 0, -dir.x);}\\\\
     \texttt{// strafe movement}\\
     \texttt{if(event->key() == Qt::Key\_W) m\_camera->translate(dir);}\\
     \texttt{if(event->key() == Qt::Key\_S) m\_camera->translate(-dir);}\\
     \texttt{if(event->key() == Qt::Key\_A) m\_camera->translate(perp);}\\
     \texttt{if(event->key() == Qt::Key\_D) m\_camera->translate(-perp);}
     
This makes it so that whenever a key is pressed, the player is moved forward one unit, backwards one unit, left one unit, or right one unit.

\item The camera should also be affected by mouse movements. Again, we’ll use a standard mouse configuration. In \texttt{View::mouseMoveEvent()}, add:

     \texttt{m\_camera->rotate(-deltaX / 100.f, -deltaY / 100.f);}
     
The camera will now adjust its pitch and yaw proportionally to how much the mouse moves. Try running the project – you should be able to move the mouse around and walk around your green quad.
\end{enumerate}


\section*{Drawing a second shape}

Great! Now we have a beautiful quad and can run around the world. But 3D games usually have more than just a single 2D plane in them, so let’s try to draw a \emph{second} shape.

\begin{enumerate}
\item In the function View::paintGL(), add this line: 

\texttt{m\_graphics->drawShape("cylinder");}

Build and run your project. But where’s the cylinder...

It turns out that it’s in the same place and has the same material as our quad. Because the camera is inside the cylinder, it can’t see it (a consequence of how OpenGL renders shapes). This probably isn’t what you want. Uh-oh!

The reason this happens is because OpenGL (which is what our graphics object uses) is a state machine. This means that unless you explicitly change a setting, such as the current material or transform applied to shapes, OpenGL will continue to use that setting. In other words, OpenGL stays in the same state until you give it a command to change that state. This is great when you want to draw many objects with near identical properties (100 red cubes, for example), but this also means that you need to explicitly reset things you are done using.

\item Try augmenting the above line of code with this:

         \texttt{m\_graphics->clearTransform();}\\
         \texttt{m\_graphics->setDefaultMaterial();}\\
         \texttt{m\_graphics->translate(glm::vec3(1.f,1.f,10.f));}\\
         \texttt{m\_graphics->scale(5);}\\
         \texttt{m\_graphics->drawShape("cylinder");}
         
You should end up with a plain cylinder in front of you and slightly to your left. Hooray!

\end{enumerate}


\section*{Some Final Words}

At this point, you should be prepared to do Warmup 1, but what you have done here will not pass for the first project. For example, you probably should not be doing all (or any) of these things in \path{view.cpp}. Again, we recommend playing around with what we have taught you in this guide!

\end{document}
